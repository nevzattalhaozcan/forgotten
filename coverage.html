
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/nevzattalhaozcan/forgotten/cmd/server/main.go (0.0%)</option>
				
				<option value="file1">github.com/nevzattalhaozcan/forgotten/internal/config/config.go (0.0%)</option>
				
				<option value="file2">github.com/nevzattalhaozcan/forgotten/internal/configtest/helper.go (0.0%)</option>
				
				<option value="file3">github.com/nevzattalhaozcan/forgotten/internal/database/connection.go (0.0%)</option>
				
				<option value="file4">github.com/nevzattalhaozcan/forgotten/internal/database/seed.go (0.0%)</option>
				
				<option value="file5">github.com/nevzattalhaozcan/forgotten/internal/handlers/server.go (0.0%)</option>
				
				<option value="file6">github.com/nevzattalhaozcan/forgotten/internal/handlers/user.go (43.2%)</option>
				
				<option value="file7">github.com/nevzattalhaozcan/forgotten/internal/middleware/auth.go (0.0%)</option>
				
				<option value="file8">github.com/nevzattalhaozcan/forgotten/internal/models/user.go (0.0%)</option>
				
				<option value="file9">github.com/nevzattalhaozcan/forgotten/internal/repository/mocks/mock_repositories.go (0.0%)</option>
				
				<option value="file10">github.com/nevzattalhaozcan/forgotten/internal/repository/user.go (50.0%)</option>
				
				<option value="file11">github.com/nevzattalhaozcan/forgotten/internal/services/user.go (63.6%)</option>
				
				<option value="file12">github.com/nevzattalhaozcan/forgotten/pkg/testutil/fixtures.go (0.0%)</option>
				
				<option value="file13">github.com/nevzattalhaozcan/forgotten/pkg/testutil/setupdb.go (0.0%)</option>
				
				<option value="file14">github.com/nevzattalhaozcan/forgotten/pkg/utils/hash.go (0.0%)</option>
				
				<option value="file15">github.com/nevzattalhaozcan/forgotten/pkg/utils/jwt.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "log"

        "github.com/nevzattalhaozcan/forgotten/internal/config"
        "github.com/nevzattalhaozcan/forgotten/internal/database"
        "github.com/nevzattalhaozcan/forgotten/internal/handlers"
)

func main() <span class="cov0" title="0">{
        cfg := config.Load()

        db, err := database.Connect(cfg)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to connect to the database: %v", err)
        }</span>

        <span class="cov0" title="0">server := handlers.NewServer(db, cfg)
        

        addr := fmt.Sprintf("%s:%s", cfg.Server.Host, cfg.Server.Port)
        log.Printf("starting server on %s", addr)

        if err := server.Start(addr); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to start the server: %v", err)
        }</span>
}</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "log"
        "os"
        "strconv"

        "github.com/joho/godotenv"
)

type Config struct {
        Server ServerConfig
        Database DatabaseConfig
        JWT JWTConfig
        App AppConfig
}

type ServerConfig struct {
        Port string
        Host string
        Environment string
}

type DatabaseConfig struct {
        URL string
        MaxOpenConns int
        MaxIdleConns int
}

type JWTConfig struct {
        Secret string
        ExpirationHours int
}

type AppConfig struct {
        Name string
        Version string
}

func Load() *Config <span class="cov0" title="0">{
        if err := godotenv.Load(); err != nil </span><span class="cov0" title="0">{
                log.Printf("no .env file found or error loading it: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;Config{
                Server: ServerConfig{
                        Port: getEnv("PORT", "8080"),
                        Host: getEnv("HOST", "localhost"),
                        Environment: getEnv("ENVIRONMENT", "development"),
                },
                Database: DatabaseConfig{
                        URL: getEnv("DATABASE_URL", "postgres://user:password@localhost:5432/dbname?sslmode=disable"),
                        MaxOpenConns: getEnvAsInt("DB_MAX_OPEN_CONNS", 25),
                        MaxIdleConns: getEnvAsInt("DB_MAX_IDLE_CONNS", 5),
                },
                JWT: JWTConfig{
                        Secret: getEnv("JWT_SECRET", "default_secret"),
                        ExpirationHours: getEnvAsInt("JWT_EXPIRATION_HOURS", 24),
                },
                App: AppConfig{
                        Name: getEnv("APP_NAME", "Forgotten"),
                        Version: getEnv("APP_VERSION", "1.0.0"),
                },
        }</span>
}

func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvAsInt(name string, defaultVal int) int <span class="cov0" title="0">{
        if value := os.Getenv(name); value != "" </span><span class="cov0" title="0">{
                if intValue, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                        return intValue
                }</span>
                <span class="cov0" title="0">log.Printf("invalid integer value for %s: %s. using default: %d", name, value, defaultVal)</span>
        }
        <span class="cov0" title="0">return defaultVal</span>
}</pre>
		
		<pre class="file" id="file2" style="display: none">package configtest

import "github.com/nevzattalhaozcan/forgotten/internal/config"

func New() *config.Config <span class="cov0" title="0">{
    return &amp;config.Config{
        Server: config.ServerConfig{
            Port:        "8080",
            Host:        "localhost",
            Environment: "development",
        },
        Database: config.DatabaseConfig{
            URL:          "postgres://test:test@localhost:5432/test_db?sslmode=disable",
            MaxOpenConns: 5,
            MaxIdleConns: 2,
        },
        JWT: config.JWTConfig{
            Secret:          "testsecret",
            ExpirationHours: 24,
        },
        App: config.AppConfig{
            Name:    "TestApp",
            Version: "1.0.0",
        },
    }
}</pre>
		
		<pre class="file" id="file3" style="display: none">package database

import (
        "log"

        "github.com/nevzattalhaozcan/forgotten/internal/config"
        "github.com/nevzattalhaozcan/forgotten/internal/models"
        "gorm.io/driver/postgres"
        "gorm.io/gorm"
        "gorm.io/gorm/logger"
)

func Connect(cfg *config.Config) (*gorm.DB, error)  <span class="cov0" title="0">{
        logLevel := logger.Silent
        if cfg.Server.Environment == "development" </span><span class="cov0" title="0">{
                logLevel = logger.Info
        }</span>

        <span class="cov0" title="0">db, err := gorm.Open(postgres.Open(cfg.Database.URL), &amp;gorm.Config{
                Logger: logger.Default.LogMode(logLevel),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">sqlDB, err := db.DB()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">sqlDB.SetMaxOpenConns(cfg.Database.MaxOpenConns)
        sqlDB.SetMaxIdleConns(cfg.Database.MaxIdleConns)

        if err := autoMigrate(db); err != nil </span><span class="cov0" title="0">{
                log.Printf("migration error: %v", err)
                return nil, err
        }</span>

        // Seed the database with initial data for testing
        <span class="cov0" title="0">if cfg.Server.Environment == "development" </span><span class="cov0" title="0">{
                if err := SeedForTest(db); err != nil </span><span class="cov0" title="0">{
                        log.Printf("seeding error: %v", err)
                        // Don't fail if seeding fails, just log it
                }</span>
        }

        <span class="cov0" title="0">log.Println("Database connected successfully")
        return db, nil</span>
}

func autoMigrate(db *gorm.DB) error <span class="cov0" title="0">{
        return db.AutoMigrate(
                models.User{},
        )
}</pre>
		
		<pre class="file" id="file4" style="display: none">package database

import (
        "encoding/json"
        "log"
        "os"

        "github.com/nevzattalhaozcan/forgotten/internal/models"
        "github.com/nevzattalhaozcan/forgotten/pkg/utils"
        "gorm.io/gorm"
)

type SeedUser struct {
        Username string `json:"username"`
        Email    string `json:"email"`
        Password string `json:"password"`
        FirstName string `json:"first_name"`
        LastName  string `json:"last_name"`
        IsActive  bool   `json:"is_active"`
}

type SeedData struct {
        Users []SeedUser `json:"users"`
}

func Seed(db *gorm.DB) error <span class="cov0" title="0">{
        log.Println("starting database seeding")
        
        var userCount int64
        
        db.Model(&amp;models.User{}).Count(&amp;userCount)
        if userCount &gt; 0 </span><span class="cov0" title="0">{
                log.Println("database already seeded")
                return nil
        }</span>

        <span class="cov0" title="0">data, err := os.ReadFile("data/seed_users.json")
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("failed to read seed file: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">var seedData SeedData
        if err := json.Unmarshal(data, &amp;seedData); err != nil </span><span class="cov0" title="0">{
                log.Printf("failed to unmarshal seed data: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">for _, seedUser := range seedData.Users </span><span class="cov0" title="0">{
                hashedPassword, err := utils.HashPassword(seedUser.Password)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("failed to hash password for user %s: %v", seedUser.Username, err)
                        continue</span>
                }

                <span class="cov0" title="0">user := &amp;models.User{
                        Username:  seedUser.Username,
                        Email:     seedUser.Email,
                        PasswordHash:  hashedPassword,
                        FirstName: seedUser.FirstName,
                        LastName:  seedUser.LastName,
                        IsActive:  seedUser.IsActive,
                }

                if err := db.Create(user).Error; err != nil </span><span class="cov0" title="0">{
                        log.Printf("failed to create user %s: %v", seedUser.Username, err)
                        return err
                }</span>
                <span class="cov0" title="0">log.Printf("created user: %s", seedUser.Username)</span>
        }
        <span class="cov0" title="0">log.Printf("database seeding completed - %d users created", len(seedData.Users))
        return nil</span>
}

func SeedForTest(db *gorm.DB) error <span class="cov0" title="0">{
        log.Println("starting test database seeding")

        if err := db.Exec("DELETE FROM users").Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := db.Exec("ALTER SEQUENCE users_id_seq RESTART WITH 1").Error; err != nil </span><span class="cov0" title="0">{
                log.Printf("could not reset user ID sequence: %v", err)
        }</span>

        <span class="cov0" title="0">return Seed(db)</span>
}</pre>
		
		<pre class="file" id="file5" style="display: none">package handlers

import (
        "net/http"

        "github.com/gin-contrib/cors"
        "github.com/gin-gonic/gin"
        "github.com/nevzattalhaozcan/forgotten/internal/config"
        "github.com/nevzattalhaozcan/forgotten/internal/middleware"
        "github.com/nevzattalhaozcan/forgotten/internal/repository"
        "github.com/nevzattalhaozcan/forgotten/internal/services"
        "gorm.io/gorm"
)

type Server struct {
        db *gorm.DB
        config *config.Config
        router *gin.Engine
}

func NewServer(db *gorm.DB, config *config.Config) *Server <span class="cov0" title="0">{
        server := &amp;Server{
                db: db,
                config: config,
                router: gin.Default(),
        }
        server.setupRoutes()
        return server
}</span>

func (s *Server) setupRoutes() <span class="cov0" title="0">{
        s.router.Use(cors.Default())

        s.router.HEAD("/health", func(c *gin.Context) </span><span class="cov0" title="0">{        c.Status(http.StatusOK)        }</span>)

        <span class="cov0" title="0">userRepo := repository.NewUserRepository(s.db)
        userService := services.NewUserService(userRepo, s.config)
        userHandler := NewUserHandler(userService)

        api := s.router.Group("/api/v1")
        </span><span class="cov0" title="0">{
                api.POST("/auth/register", userHandler.Register)
                api.POST("/auth/login", userHandler.Login)
        }</span>

        <span class="cov0" title="0">protected := api.Group("/")
        protected.Use(middleware.AuthMiddleware(s.config))
        </span><span class="cov0" title="0">{
                protected.GET("/profile", userHandler.GetProfile)
                protected.GET("/users/:id", middleware.AuthorizeSelf(), userHandler.GetUser)
        }</span>
}

func (s *Server) Start(addr string) error <span class="cov0" title="0">{
        return s.router.Run(addr)
}</pre>
		
		<pre class="file" id="file6" style="display: none">package handlers

import (
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
        "github.com/go-playground/validator/v10"
        "github.com/nevzattalhaozcan/forgotten/internal/models"
        "github.com/nevzattalhaozcan/forgotten/internal/services"
)

type UserHandler struct {
        userService *services.UserService
        validator *validator.Validate
}

func NewUserHandler(userService *services.UserService) *UserHandler <span class="cov8" title="1">{
        return &amp;UserHandler{
                userService: userService,
                validator: validator.New(),
        }
}</span>

func (h *UserHandler) Register(c *gin.Context) <span class="cov8" title="1">{
        var req models.RegisterRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">if err := h.validator.Struct(&amp;req); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">user, err := h.userService.Register(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusCreated, gin.H{
                "message": "user created successfully",
                "user":    user,
        })</span>
}

func (h *UserHandler) Login(c *gin.Context) <span class="cov8" title="1">{
        var req models.LoginRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">if err := h.validator.Struct(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">token, user, err := h.userService.Login(&amp;req)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
                return
        }</span>
        
        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "message": "login successful",
                "token":   token,
                "user":    user,
        })</span>
}

func (h *UserHandler) GetProfile(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "user not found in context"})
                return
        }</span>

        <span class="cov0" title="0">user, err := h.userService.GetUserByID(userID.(uint))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "user not found"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "user": user,
        })</span>
}

func (h *UserHandler) GetUser(c *gin.Context) <span class="cov0" title="0">{
        idParam := c.Param("id")
        id, err := strconv.ParseUint(idParam, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid user ID"})
                return
        }</span>

        <span class="cov0" title="0">user, err := h.userService.GetUserByID(uint(id))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"user": user})</span>
}

</pre>
		
		<pre class="file" id="file7" style="display: none">package middleware

import (
        "net/http"
        "strconv"
        "strings"

        "github.com/gin-gonic/gin"
        "github.com/nevzattalhaozcan/forgotten/internal/config"
        "github.com/nevzattalhaozcan/forgotten/pkg/utils"
)

func AuthMiddleware(cfg *config.Config) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                authHeader := c.GetHeader("Authorization")
                if authHeader == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "authorization header is required"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">tokenString := strings.Replace(authHeader, "Bearer ", "", 1)
                claims, err := utils.ValidateJWT(tokenString, cfg.JWT.Secret)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid token"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Set("user_id", claims.UserID)
                c.Set("user_email", claims.Email)
                c.Next()</span>
        }
}

func AuthorizeSelf() gin.HandlerFunc <span class="cov0" title="0">{
        return func (c *gin.Context) </span><span class="cov0" title="0">{
                ctxUserIDRaw, exists := c.Get("user_id")
                if !exists </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "user not authenticated"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">ctxUserID, ok := ctxUserIDRaw.(uint)
                if !ok </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid user ID in context"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">idParam := c.Param("id")
                if idParam == "" </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                <span class="cov0" title="0">pathID, err := strconv.ParseUint(idParam, 10, 32)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": "invalid user ID"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">if uint(pathID) != ctxUserID </span><span class="cov0" title="0">{
                        c.JSON(http.StatusForbidden, gin.H{"error": "forbidden"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}</pre>
		
		<pre class="file" id="file8" style="display: none">package models

import (
        "time"

        "gorm.io/gorm"
)

type User struct {
        ID uint `json:"id" gorm:"primaryKey"`
        Username string `json:"username" gorm:"uniqueIndex;not null" validate:"required,min=3,max=50"`
        Email string `json:"email" gorm:"uniqueIndex;not null" validate:"required,email"`
        PasswordHash string `json:"-" gorm:"not null"`
        FirstName string `json:"first_name" validate:"min=2,max=50"`
        LastName string `json:"last_name" validate:"min=2,max=50"`
        IsActive bool `json:"is_active" gorm:"default:true"`
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
        DeletedAt gorm.DeletedAt `json:"-" gorm:"index"`
}

type UserResponse struct {
        ID        uint      `json:"id"`
        Username  string    `json:"username"`
        Email     string    `json:"email"`
        FirstName string    `json:"first_name"`
        LastName  string    `json:"last_name"`
        IsActive  bool      `json:"is_active"`
        CreatedAt time.Time `json:"created_at"`
}

type LoginRequest struct {
        Email    string `json:"email" validate:"required,email"`
        Password string `json:"password" validate:"required,min=6"`
}

type RegisterRequest struct {
        Username  string `json:"username" validate:"required,min=3,max=50"`
        Email     string `json:"email" validate:"required,email"`
        Password  string `json:"password" validate:"required,min=6"`
        FirstName string `json:"first_name" validate:"required,min=2,max=50"`
        LastName  string `json:"last_name" validate:"required,min=2,max=50"`
}

func (u *User) ToResponse() UserResponse <span class="cov0" title="0">{
        return UserResponse{
                ID:        u.ID,
                Username:  u.Username,
                Email:     u.Email,
                FirstName: u.FirstName,
                LastName:  u.LastName,
                IsActive:  u.IsActive,
                CreatedAt: u.CreatedAt,
        }
}</pre>
		
		<pre class="file" id="file9" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: internal/repository/interfaces.go

// Package mock_repository is a generated GoMock package.
package mock_repository

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        models "github.com/nevzattalhaozcan/forgotten/internal/models"
)

// MockUserRepository is a mock of UserRepository interface.
type MockUserRepository struct {
        ctrl     *gomock.Controller
        recorder *MockUserRepositoryMockRecorder
}

// MockUserRepositoryMockRecorder is the mock recorder for MockUserRepository.
type MockUserRepositoryMockRecorder struct {
        mock *MockUserRepository
}

// NewMockUserRepository creates a new mock instance.
func NewMockUserRepository(ctrl *gomock.Controller) *MockUserRepository <span class="cov0" title="0">{
        mock := &amp;MockUserRepository{ctrl: ctrl}
        mock.recorder = &amp;MockUserRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserRepository) EXPECT() *MockUserRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockUserRepository) Create(user *models.User) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", user)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Create indicates an expected call of Create.
func (mr *MockUserRepositoryMockRecorder) Create(user interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockUserRepository)(nil).Create), user)
}</span>

// Delete mocks base method.
func (m *MockUserRepository) Delete(id uint) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", id)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockUserRepositoryMockRecorder) Delete(id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockUserRepository)(nil).Delete), id)
}</span>

// GetByEmail mocks base method.
func (m *MockUserRepository) GetByEmail(email string) (*models.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetByEmail", email)
        ret0, _ := ret[0].(*models.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetByEmail indicates an expected call of GetByEmail.
func (mr *MockUserRepositoryMockRecorder) GetByEmail(email interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByEmail", reflect.TypeOf((*MockUserRepository)(nil).GetByEmail), email)
}</span>

// GetByID mocks base method.
func (m *MockUserRepository) GetByID(id uint) (*models.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetByID", id)
        ret0, _ := ret[0].(*models.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetByID indicates an expected call of GetByID.
func (mr *MockUserRepositoryMockRecorder) GetByID(id interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByID", reflect.TypeOf((*MockUserRepository)(nil).GetByID), id)
}</span>

// GetByUsername mocks base method.
func (m *MockUserRepository) GetByUsername(username string) (*models.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetByUsername", username)
        ret0, _ := ret[0].(*models.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetByUsername indicates an expected call of GetByUsername.
func (mr *MockUserRepositoryMockRecorder) GetByUsername(username interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByUsername", reflect.TypeOf((*MockUserRepository)(nil).GetByUsername), username)
}</span>

// List mocks base method.
func (m *MockUserRepository) List(limit, offset int) ([]*models.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "List", limit, offset)
        ret0, _ := ret[0].([]*models.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// List indicates an expected call of List.
func (mr *MockUserRepositoryMockRecorder) List(limit, offset interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "List", reflect.TypeOf((*MockUserRepository)(nil).List), limit, offset)
}</span>

// Update mocks base method.
func (m *MockUserRepository) Update(user *models.User) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", user)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Update indicates an expected call of Update.
func (mr *MockUserRepositoryMockRecorder) Update(user interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockUserRepository)(nil).Update), user)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package repository

import (
        "github.com/nevzattalhaozcan/forgotten/internal/models"
        "gorm.io/gorm"
)

type userRepository struct {
        db *gorm.DB
}

func NewUserRepository(db *gorm.DB) *userRepository <span class="cov8" title="1">{
        return &amp;userRepository{db: db}
}</span>

func (r *userRepository) Create(user *models.User) error <span class="cov8" title="1">{
        return r.db.Create(user).Error
}</span>

func (r *userRepository) GetByID(id uint) (*models.User, error) <span class="cov8" title="1">{
        var user models.User
        err := r.db.First(&amp;user, id).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;user, nil</span>
}

func (r *userRepository) GetByEmail(email string) (*models.User, error) <span class="cov8" title="1">{
        var user models.User
        err := r.db.Where("email = ?", email).First(&amp;user).Error
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;user, nil</span>
}

func (r *userRepository) GetByUsername(username string) (*models.User, error) <span class="cov0" title="0">{
        var user models.User
        err := r.db.Where("username = ?", username).First(&amp;user).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (r *userRepository) Update(user *models.User) error <span class="cov8" title="1">{
        return r.db.Save(user).Error
}</span>

func (r *userRepository) Delete(id uint) error <span class="cov0" title="0">{
        return r.db.Delete(&amp;models.User{}, id).Error
}</span>

func (r *userRepository) List(limit, offset int) ([]*models.User, error) <span class="cov0" title="0">{
        var users []*models.User
        err := r.db.Limit(limit).Offset(offset).Find(&amp;users).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return users, nil</span>
}</pre>
		
		<pre class="file" id="file11" style="display: none">package services

import (
        "errors"

        "github.com/nevzattalhaozcan/forgotten/internal/config"
        "github.com/nevzattalhaozcan/forgotten/internal/models"
        "github.com/nevzattalhaozcan/forgotten/internal/repository"
        "github.com/nevzattalhaozcan/forgotten/pkg/utils"
        "gorm.io/gorm"
)

type UserService struct {
        userRepo repository.UserRepository
        config  *config.Config
}

func NewUserService(userRepo repository.UserRepository, config *config.Config) *UserService <span class="cov8" title="1">{
        return &amp;UserService{
                userRepo: userRepo,
                config:   config,
        }
}</span>

func (s *UserService) Register(req *models.RegisterRequest) (*models.UserResponse, error) <span class="cov8" title="1">{
        _, err := s.userRepo.GetByEmail(req.Email)
        if err == nil </span><span class="cov8" title="1">{
                return nil, errors.New("email already exists")
        }</span>

        <span class="cov8" title="1">_, err = s.userRepo.GetByUsername(req.Username)
        if err == nil </span><span class="cov0" title="0">{
                return nil, errors.New("username already exists")
        }</span>

        <span class="cov8" title="1">hashedPassword, err := utils.HashPassword(req.Password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">user := &amp;models.User{
                Username: req.Username,
                Email:    req.Email,
                PasswordHash: hashedPassword,
                FirstName: req.FirstName,
                LastName:  req.LastName,
                IsActive: true,
        }

        if err := s.userRepo.Create(user); err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("failed to create user")
        }</span>

        <span class="cov8" title="1">response := user.ToResponse()
        return &amp;response, nil</span>
}

func (s *UserService) Login(req *models.LoginRequest) (string, *models.UserResponse, error) <span class="cov8" title="1">{
        user, err := s.userRepo.GetByEmail(req.Email)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                        return "", nil, errors.New("invalid email or password")
                }</span>
        }

        <span class="cov8" title="1">if !utils.CheckPasswordHash(req.Password, user.PasswordHash) </span><span class="cov0" title="0">{
                return "", nil, errors.New("invalid email or password")
        }</span>

        <span class="cov8" title="1">token, err := utils.GenerateJWT(
                user.ID, 
                user.Email, 
                s.config.JWT.Secret, 
                s.config.JWT.ExpirationHours,
        )
        if err != nil </span><span class="cov0" title="0">{
                return "", nil, errors.New("failed to generate token")
        }</span>

        <span class="cov8" title="1">response := user.ToResponse()
        return token, &amp;response, nil</span>
}

func (s *UserService) GetUserByID(id uint) (*models.UserResponse, error) <span class="cov0" title="0">{
        user, err := s.userRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, errors.New("user not found")
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">response := user.ToResponse()
        return &amp;response, nil</span>
}</pre>
		
		<pre class="file" id="file12" style="display: none">package test_helpers

import (
        "encoding/json"
        "log"
        "os"

        "github.com/nevzattalhaozcan/forgotten/internal/database"
        "github.com/nevzattalhaozcan/forgotten/internal/models"
)

func CreateUser() (*models.User, error) <span class="cov0" title="0">{
        data, err := os.ReadFile("../../data/seed_users.json")
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("failed to read seed file: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">var seedData database.SeedData
        if err := json.Unmarshal(data, &amp;seedData); err != nil </span><span class="cov0" title="0">{
                log.Printf("failed to unmarshal seed data: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">seedUser := seedData.Users[0]
        user := &amp;models.User{
                Username:     seedUser.Username,
                Email:        seedUser.Email,
                PasswordHash: seedUser.Password,
                FirstName:    seedUser.FirstName,
                LastName:     seedUser.LastName,
                IsActive:     seedUser.IsActive,
        }

        return user, nil</span>
}

func CreateRegisterRequest() (*models.RegisterRequest, error) <span class="cov0" title="0">{
        data, err := os.ReadFile("../../data/seed_users.json")
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("failed to read seed file: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">var seedData database.SeedData
        if err := json.Unmarshal(data, &amp;seedData); err != nil </span><span class="cov0" title="0">{
                log.Printf("failed to unmarshal seed data: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">seedUser := seedData.Users[0]
        registerReq := &amp;models.RegisterRequest{
                Username:     seedUser.Username,
                Email:        seedUser.Email,
                Password:     seedUser.Password,
                FirstName:    seedUser.FirstName,
                LastName:     seedUser.LastName,
        }

        return registerReq, nil</span>
}

func CreateLoginRequest() (*models.LoginRequest, error) <span class="cov0" title="0">{
        data, err := os.ReadFile("../../data/seed_users.json")
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("failed to read seed file: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">var seedData database.SeedData
        if err := json.Unmarshal(data, &amp;seedData); err != nil </span><span class="cov0" title="0">{
                log.Printf("failed to unmarshal seed data: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">seedUser := seedData.Users[0]
        loginReq := &amp;models.LoginRequest{
                Email:    seedUser.Email,
                Password: seedUser.Password,
        }

        return loginReq, nil</span>
}</pre>
		
		<pre class="file" id="file13" style="display: none">package test_helpers

import (
        "github.com/nevzattalhaozcan/forgotten/internal/models"
        "gorm.io/driver/sqlite"
        "gorm.io/gorm"
        "gorm.io/gorm/logger"
)

func SetupTestDB() (*gorm.DB, error) <span class="cov0" title="0">{
        db, err := gorm.Open(sqlite.Open(":memory:"), &amp;gorm.Config{
                Logger: logger.Default.LogMode(logger.Silent),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">err = db.AutoMigrate(
                &amp;models.User{},
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return db, nil</span>
}

func CleanupTestDB(db *gorm.DB) error <span class="cov0" title="0">{
        tables := []string{"users"}
        
        for _, table := range tables </span><span class="cov0" title="0">{
                if err := db.Exec("DELETE FROM " + table).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}</pre>
		
		<pre class="file" id="file14" style="display: none">package utils

import "golang.org/x/crypto/bcrypt"

func HashPassword(password string) (string, error) <span class="cov0" title="0">{
        bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        return string(bytes), err
}</span>

func CheckPasswordHash(password, hash string) bool <span class="cov0" title="0">{
        err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
        return err == nil
}</pre>
		
		<pre class="file" id="file15" style="display: none">package utils

import (
        "errors"
        "time"

        "github.com/golang-jwt/jwt/v5"
)

type Claims struct {
        UserID uint `json:"user_id"`
        Email string `json:"email"`
        jwt.RegisteredClaims
}

func GenerateJWT(userID uint, email, secret string, hours int) (string, error) <span class="cov0" title="0">{
        claims := &amp;Claims{
                UserID: userID,
                Email:  email,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(time.Now().Add(time.Duration(hours) * time.Hour)),
                        IssuedAt:  jwt.NewNumericDate(time.Now()),
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString([]byte(secret))
}</span>

func ValidateJWT(tokenString, secret string) (*Claims, error) <span class="cov0" title="0">{
        claims := &amp;Claims{}

        token, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                return []byte(secret), nil
        }</span>)

        <span class="cov0" title="0">if err != nil || !token.Valid </span><span class="cov0" title="0">{
                return nil, errors.New("invalid token")
        }</span>

        <span class="cov0" title="0">return claims, nil</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
